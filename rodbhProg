--[[
	TODO:
		1. Automatically place torch every 8? blocks and every 3? levels.
]]

--========= Load rodbh API used throughout the program ========--
os.loadAPI("rodbh")

--========= Gather all arguments into a table =======--
local tArgs = { ... }

--========= Print help message when no arguments were provided =======------
if tArgs[1] == nil then
local help = [[Uzycie: rodbh <dlugosc> <szerokosc> <wysokosc> [kanal wifi] <rodzaj pomieszczenia> [kierunek kopania]

<> - argumenty obowiazkowe
[] - argumenty opcjonalne
Dostepne rodzaje pomieszczen: nofill, tunnel, room, wall, floor, ceiling
Pomieszczenia floor i ceiling NIE! przyjmuja argumentu wysokosc
Dostepne kierunki: left/right up/down"]]
print(help)
else

--======== An array of variables used throughout the program ========--
local variables = {
	x = 0; y = 0; z = 0;
	xTmp = 0; yTmp = 0; zTmp = 0;
	direction = 1; directionTmp = 1;
	length = nil;
	width = nil;
	height = nil;
	roomType = nil;
	horizontalBool = false;
	verticalBool = false;
	extension = false;
	recId = nil;
}
--== Just shorter way of getting into array above ==--
local v = variables	

--===== Going through table of arguments for part of needed variables =====--
for i, val in ipairs(tArgs) do
		if val == "tunnel" or val == "room" or val == "nofill" 
		or val == "wall" or val == "floor" or val == "ceiling" 
		or val == "excavate" or val == "continue" then
			v.roomType = val
		elseif val == "left" then v.horizontalBool = false
		elseif val == "right" then v.horizontalBool = true
		elseif val == "up" then v.verticalBool = false
		elseif val == "down" then v.verticalBool = true
		elseif val == "extension" then v.extensiton = true
		end
end

--====== Check if viable roomtype was provided as argument =====--
assert(v.roomType, "Nie rozpoznalem prawidlowego rodzaju pomieszczenia")

if v.roomType == "tunnel" or v.roomType == "room" 
	or v.roomType == "nofill" or v.roomType == "wall" then
	
	v.length = assert(tonumber(tArgs[1]), "Nieprawidlowa dlugosc pomieszczenia.")
	v.width = assert(tonumber(tArgs[2]), "Nieprawidlowa szerokosc pomieszczenia.") - 1
	v.height = assert(tonumber(tArgs[3]), "Nieprawidlowa wysokosc pomieszczenia.")
	v.recId = tonumber(tArgs[4])
	
elseif v.roomType == "ceiling" or v.roomType == "floor" 
	or v.roomType == "excavate" then

	v.length = assert(tonumber(tArgs[1]), "Nieprawidlowa dlugosc pomieszczenia.")
	v.width = assert(tonumber(tArgs[2]), "Nieprawidlowa szerokosc pomieszczenia.") - 1
	v.recId = tonumber(tArgs[3])
	
elseif v.roomType == "continue" then
	if fs.exists("rodbhPos.tmp") then
		for line in io.lines("rodbhPos.tmp") do
			for k, val in string.gmatch(line, "(%w+)=(%w+)") do
				if k == x or k == y or k == z or k == direction 
					or k == length or k == height or k == width then
					v[k] = assert(tonumber(val), "Blad pobierania danych z pliku rodbh.tmp")
				elseif k == horizontalBool or k == verticalBool or k == extension then
					v[k] = toBool(val)
				else 
					v[k] = assert(val, "Blad pobierania danych z pliku rodbh.tmp")
				end
			end
		end
	end				
end

local xStart, yStart, zStart  = x + 1, y + 1, z + 1

--========= Messages to be printed on certain points of running the program =======--
	--== Message printed upon succesfully run program ==-- 
if v.roomType == "floor" or v.roomType == "ceiling" or v.roomType == "excavate" then
	endMsg = "Tworzenie pomieszczenia typu " .. v.roomType .. " o wymiarach " .. v.length .. " x " ..  v.width + 1 .. " zakonczone powodzeniem."
	else
	endMsg = "Tworzenie pomieszczenia typu " .. v.roomType .. " o wymiarach " .. v.length .. " x " ..  v.width + 1 .. " x " .. v.height .. " zakonczone powodzeniem."
end
	--== Message printed when inventory is full ==--
local invMsg = "Skrzynka na rozladunek pelna, czekam na miejsce do rozladunku."
	--== Message printed when turtle's lacking building material for filling ==--
local fillMsg = "Brak budulca, wstaw budulec w slot 1 lub do wyznaczonej do tego skrzynki."
	--== Message printed when out of fuel ==--
local fuelMsg = "Brak paliwa, wloz paliwo w slot 16."
	--== Message printed then bedrock was reached. ==--
local bedrockMsg = [[Osiagnieto poziom bedrocka.
Wracam do punktu rozpoczecia pracy.]]
	--== Message printed when resuming program ==--
local continueMsg = "Kontynuuje prace..."

--=========== Function responsible for printing messages and sending them over RedNet ======--
function sendAndPrint(message)
	print(message)
	if v.recId ~= nil then
		rednet.send(v.recId, message)
	end
end

--======= Function converting string to boolean used for importing data from file ======--
function toBool(var)
	if var == "true" then
		return true
	elseif var == "false" then
		return false
	else
		return nil
	end
end

--=========== Functions responsible for moving turtle with location memory =======--
function moveForward(noCheck)
	noCheck = noCheck or false
	if not noCheck then checkAll() end
	if not turtle.forward() then
		if not turtle.detect() then
			if turtle.attack() then
				turtle.suck()
			else
				goToStart()
				v.excavateFinish = true
				sendAndPrint(bedrockMsg)
				return false
		elseif not turtle.dig() then
			goToStart()
			v.excavateFinish = true
			sendAndPrint(bedrockMsg)
			return false
		end
		sleep(0)
		moveForward(true)
	else
		if v.direction == 1 then v.z = v.z + 1
		elseif v.direction == 2 then v.x = v.x - 1
		elseif v.direction == 3 then v.z = v.z - 1
		elseif v.direction == 4 then v.x = v.x + 1
		end
		local tempPosition = io.open("rodbhPos.tmp", "w")
		for k, val in pairs(v) do
			tempPosition:write(tostring(k) .. "=" .. tostring(val) .. "\n")
		end
		tempPosition:close()
		return true
	end
end

function moveUp(noCheck)
	noCheck = noCheck or false
	if noCheck == false then checkAll() end
	if turtle.up() == false then
		if turtle.detectUp() == false then
			turtle.attackUp()
			turtle.suckUp()
		elseif turtle.digUp() == false then
			goToStart()
			v.excavateFinish = true
			sendAndPrint(bedrockMsg)
		end
		sleep(0.1)
		if v.excavateFinish == false then moveUp() end
	else
		v.y = v.y + 1
		local tempPosition = io.open("rodbhPos.tmp", "w")
		for k, val in pairs(v) do
			tempPosition:write(k .. "=" .. tostring(val) .. "\n")
		end
		tempPosition:close()
	end
end

function moveDown(noCheck)
	noCheck = noCheck or false
	if noCheck == false then checkAll() end
	if turtle.down() == false then
		if turtle.detectDown() == false then
			turtle.attackDown()
			turtle.suckDown()
		elseif turtle.digDown() == false then
			goToStart()
			v.excavateFinish = true
			sendAndPrint(bedrockMsg)
		end
		sleep(0.1)
		if excavateFinish == false then moveDown() end
	else
		v.y = v.y - 1
		local tempPosition = io.open("rodbhPos.tmp", "w")
		for k, val in pairs(v) do
			tempPosition:write(k .. "=" .. tostring(val) .. "\n")
		end
		tempPosition:close()
	end
end

function leftTurn(v)
	turtle.turnLeft()
	v.direction = v.direction + 1
	if v.direction == 5 then v.direction = 1 end
end

function rightTurn()
	turtle.turnRight()
	v.direction = v.direction - 1
	if v.direction == 0 then v.direction = 4 end
end

function turnAround()
	rightTurn()
	rightTurn()
end

function faceNorth()
	if v.direction == 1 then
		return true
	elseif v.direction == 2 then
		rightTurn()
		return true
	elseif v.direction == 3 then
		turnAround()
		return true
	elseif v.direction == 4 then
		leftTurn()
		return true
	end
end

function faceWest()
	if v.direction == 1 then
		leftTurn()
		return true
	elseif v.direction == 2 then
		return true
	elseif v.direction == 3 then
		rightTurn()
		return true
	elseif v.direction == 4 then
		turnAround()
		return true
	end
end
	
function faceSouth()
	if v.direction == 1 then
		turnAround()
		return true
	elseif v.direction == 2 then
		leftTurn()
		return true
	elseif v.direction == 3 then
		return true
	elseif v.direction == 4 then
		rightTurn()
		return true
	end
end

function faceEast()
	if v.direction == 1 then
		rightTurn()
		return true
	elseif v.direction == 2 then
		turnAround()
		return true
	elseif v.direction == 3 then
		leftTurn()
		return true
	elseif v.direction == 4 then
		return true
	end
end

function goToStart()
	v.xTmp, v.yTmp, v.zTmp = v.x, v.y, v.z
	v.directionTmp = v.direction
	
	if v.y < 0 then
		for i = 1, math.abs(v.yTmp), 1 do moveUp(true) end
	else
		for i = 1, math.abs(v.yTmp), 1 do moveDown(true) end
	end
	
	if v.x == 0 then
		faceSouth()
	elseif v.x < 0 then
		faceEast()
	else
		faceWest()
	end
	for i = 1, math.abs(v.xTmp), 1 do moveForward(true) end
	
	faceSouth()
	for i = 1, v.zTmp, 1 do moveForward(true) end
	
end

function goToEnd()
	faceNorth()
	while abs.math(v.z) < math.abs(v.zTmp) do moveForward() end
	if v.xTmp < 0 then
		faceWest()
	else
		faceEast()
	end
	while math.abs(v.x) < math.abs(v.xTmp) do moveForward() end
	
	if v.yTmp < 0 then	
		while v.y > v.yTmp do moveDown() end
	else
		while v.y < v.yTmp do moveUp() end
	end
	
	if v.directionTmp == 1 then faceNorth()
		elseif v.directionTmp == 2 then faceWest()
		elseif v.directionTmp == 3 then faceSouth()
		elseif v.directionTmp == 4 then faceEast()
	end
end

function swapHorizontal()
	v.horizontalBool = not v.horizontalBool
end
	
function swapLengthHorizontal()
	horizontalLengthBool = not horizontalLengthBool
end
	
function swapVertical()
	v.verticalBool = not v.verticalBool
end

function horizontalFaceFront(front)
	if v.horizontalBool == front then 
			faceEast()
		else
			faceWest()
		end
end

--=========== Checking if there's enough fuel, fill and room in the inventory ===========--

function checkInv()
	local emptySlots = 0
	for i = 2, 15, 1 do
		if turtle.getItemCount(i) == 0 then
			emptySlots = emptySlots + 1
		end
	end
	if emptySlots <= 1 then
		return false
	else
		return true
	end
end

function checkFuel(start)
	start = start or false
	if start == true then
		if turtle.getFuelLevel() < (math.abs(v.xTmp) + math.abs(v.yTmp) + math.abs(v.zTmp) + 2) * 2 then
			return false
		else
			return true
		end
	else
		if turtle.getFuelLevel() < math.abs(v.x) + math.abs(v.y) + math.abs(v.z) + 2 then
			return false
		else
			return true
		end
	end
end	

function getFuel(start)
		turtle.select(16)
		turtle.refuel()
		return checkFuel(start or false)
end

function checkFill()
	if v.roomType ~= "nofill" and v.roomType ~= "excavate" then
		if turtle.getItemCount(1) <= 2 then
			return false
		else
			return true
		end
	end
end

function getFillChest()
	for i = 1, 8, 1 do
		if turtle.getItemSpace(i) ~= 0 then
			turtle.select(i)
			turtle.suck()
		end
	end
	return checkFill()
end

function getFill()
	local i = 1
	while turtle.getItemSpace(1) ~= 0 and i <= 16 do
		turtle.select(i)
		turtle.transferTo(1)
		i = i + 1
	end
	return checkFill()
	end

function dumpInv(all)
	local dumped = true
	if all == true then
		for i = 1, 16, 1 do
			if turtle.getItemCount(i) ~= 0 then
				turtle.select(i)
				if turtle.drop() == false then dumped = false end
			end
		end
	else
		if v.roomType == "nofill" or v.roomType == "excavate" then
			for i = 1, 15, 1 do
				if turtle.getItemCount(i) ~= 0 then
					turtle.select(i)
				if turtle.drop() == false then dumped = false end
				end
			end
		else
			for i = 2, 15, 1 do
				if turtle.getItemCount(i) ~= 0 then
					turtle.select(i)
					if turtle.compareTo(1) == false then
					if turtle.drop() == false then dumped = false end
					end
				end
			end
		end
	end
	return dumped
end

function getAll()
	goToStart()
	faceSouth()
	
	if dumpInv() == false then
		sendAndPrint(invMsg)
		while dumpInv() == false do sleep(1) end
		sendAndPrint(continueMsg)
	end
	
	if getFuel(true) == false then
		sendAndPrint(fuelMsg)
		while checkFuel(true) == false do
			turtle.select(16)
			turtle.refuel()
			sleep(1)
		end
		sendAndPrint(continueMsg)
	end
	
	if v.roomType ~= "nofill" and v.roomType ~= "excavate" then
		faceWest()
		moveForward(true)
		faceSouth()
		if getFillChest() == false then
			if getFill() == false then
				sendAndPrint(fillMsg)
				while checkFill() == false do
					getFillChest()
					getFill()
					sleep(1)
				end
				sendAndPrint(continueMsg)
			end
		end
		faceEast()
		moveForward(true)
	end
	turtle.select(1)
	goToEnd()
end
	
function checkAll()
	if checkInv() == false then getAll()
	elseif checkFuel() == false then
		if getFuel() == false then getAll() end
	elseif checkFill() == false then
		if getFill() == false then getAll() end
	end	
end

function place()
	checkAll()
	if turtle.compare(1) == false then
		if turtle.detect() == false then
			turtle.select(1)
			if turtle.place() == false then
				turtle.attack()
				turtle.suck()
				sleep(0.1)
				place()
			end
		else
			turtle.dig()
			sleep(0.1)
			place()
		end
	end
end

function placeUp()
	checkAll()
	if turtle.compareUp(1) == false then
		if turtle.detectUp() == false then
			turtle.select(1)
			if turtle.placeUp() == false then
				turtle.attackUp()
				turtle.suckUp()
				sleep(0.1)
				placeUp()
			end
		else
			turtle.digUp()
			sleep(0.1)
			placeUp()
		end
	end
end
	
function placeDown()
	checkAll()
	if turtle.compareDown(1) == false then
		if turtle.detectDown() == false then
			turtle.select(1)
			if turtle.placeDown() == false then
				turtle.attackDown()
				turtle.suckDown()
				sleep(0.1)
				placeDown()
			end
		else
			turtle.digDown()
			sleep(0.1)
			placeDown()
		end
	end
end

function nextStep()
	faceNorth()
	moveForward()
	swapVertical()
	swapHorizontal()
end

--=========== Functions containing main loops for program ===============-- 

--=== Tunnel with filled side walls, floor and ceiling ===--
function nextLayer(place)
	place = place or false
	if v.verticalBool == true then
		moveDown()
	else
		moveUp()
	end
	if place == true then
		place()
	end
	swapHorizontal()
end

function tunnel()
	for i = zStart, v.length, 1 do
		if i ~= zStart then nextStep() end
		if i == 1 then
			horizontalFaceFront(false)
			place()
			horizontalFaceFront(true)
		end
		
		for j = yStart, v.height, 1 do
			if j > yStart then nextLayer(place) end
			horizontalFaceFront(true)
			
			for k = xStart, v.width, 1 do
				if math.abs(v.y) == 0 then
					placeDown()
				elseif math.abs(v.y) == v.height-1 then
					placeUp()
				end
				if math.abs(v.x) < v.width then
					moveForward()
				else
					place()
					if math.abs(v.y) == 0 then
						placeDown()
					elseif math.abs(v.y) == v.height-1 then
						placeUp()
					end
				end
			end
			xStart = 1
		end
		yStart = 1
	end
end

--=== Room - filled all walls, floor and ceiling ===--

function room()
	for i = zStart, v.length, 1 do
		if i ~= zStart then
			nextStep()
		end
		if i == 1 then
			horizontalFaceFront(false)
			place()
			horizontalFaceFront(true)
		end
		
		for j = yStart, v.height, 1 do
			if j ~= yStart then
				nextLayer(true)
			end
			
			for k = xStart, v.width+1, 1 do
			
				if math.abs(v.y) == 0 then placeDown()
				elseif math.abs(v.y) == v.height-1 then placeUp() end
				
				if i == 1 and (v.x < -1 or v.x > 0 or math.abs(v.y) > 0) and v.extension == false then
					faceSouth()
					place()	
				elseif i == v.length then
					faceNorth()
					place()
				end
				
				horizontalFaceFront(true)
				
				if k == v.width+1 then
					place()
					if math.abs(v.y) == 0 then placeDown()
					elseif math.abs(v.y) == v.height-1 then placeUp() end
					if i == 1 and (v.x < -1 or v.x > 0 or math.abs(v.y) > 0) and v.extension == false then
						faceSouth()
						place()
						horizontalFaceFront(true)
					elseif i == v.length then
						faceNorth()
						place()
						horizontalFaceFront(true)
					end
				else
					moveForward()
				end
			end
			xStart = 1
		end
		yStart = 1
	end
end

--=== Wall ===--
function wall()
	for i = zStart, v.length, 1 do
		if i ~= iStart then 
			nextStep()
		end
		if i == 1 then
			horizontalFaceFront(false)
			place()
			horizontalFaceFront(true)
		end
		for j = yStart, v.height, 1 do
			if j ~= yStart then 
				nextLayer(true)
			end
			for k = xStart, v.width, 1 do
				if i == 1 and (v.x < -1 or v.x > 0 or math.abs(v.y) > 0) and v.extension == false then
					faceSouth()
					place()	
				elseif i == v.length then
					faceNorth()
					place()
				end
				horizontalFaceFront(true)
				if k == v.width+1 then
					place()
					if i == 1 and (v.x < -1 or v.x > 0 or math.abs(v.y) > 0) and v.extension == false then
						faceSouth()
						place()	
						horizontalFaceFront(true)
					elseif i == v.length then
						faceNorth()
						place()
						horizontalFaceFront(true)
					end
				else
					moveForward()
				end
			end
			xStart = 1
		end
		yStart = 1
	end
end
--=== Simple tunnel, only digging, no filling at all ===--

function nofill()
	for i = zStart, v.length, 1 do
		if i ~= zStart then
			nextStep()
		end
		for j = yStart, v.height, 1 do
			if j ~= yStart then
				nextLayer()
			end
			horizontalFaceFront(true)
			for k = 1, v.width, 1 do
				moveForward()
			end
			xStart = 1
		end
		yStart = 1
	end
end

--==== Placing floor, starting from below the turtle ====--

function buildFloor()
	for i = zStart, v.length, 1 do
		if i ~= zStart then
			nextStep()
		end
		for j = xStart, v.width, 1 do
			placeDown()
			moveForward()
		end
		xStart = 1
		placeDown()
	end 
end

--===== Placing ceiling, starting from below the turtle ====--

function buildCeiling()
	for i = zStart, v.length, 1 do
		if i ~= zStart then
			nextStep()
		end
		for j = xStart, v.width, 1 do
			placeUp()
			moveForward()
		end
		xStart = 1
		placeUp()
	end 
end

--===== Excavate, like build in excavate program but with more personalization ====--

function excavate()
	horizontalLengthBool = true
	while v.excavateFinish == false do
		for i = xStart, v.width + 1, 1 do
			if i ~= xStart then 
				horizontalFaceFront(true)
				moveForward()
			end
			if horizontalLengthBool == true then
				faceNorth()
			else
				faceSouth()
			end
			for j = zStart, v.length - 1, 1 do
				moveForward()
			end
			zStart = 1
			swapLengthHorizontal()
		end
		xStart = 1
		swapHorizontal()
		moveDown()
	end	
end

function build()
	for i = 5, 1, -1 do
		term.clear()
		term.setCursorPos(1,1)
		print ("Aby przerwac wcisnij Q")
		if v.roomType == "floor" or v.roomType == "ceiling" or v.roomType == "excavate" then
			print ("Kopanie pomieszczenia " .. v.roomType .. " o wymiarach " .. v.length .. " x " ..  v.width + 1 .. " rozpocznie sie za: " .. i)
			else
			print ("Kopanie pomieszczenia " .. v.roomType .. " o wymiarach " .. v.length .. " x " ..  v.width + 1 .. " x " .. v.height .. " rozpocznie sie za: " .. i)
		end
		sleep(1)
	end

	term.clear()
	term.setCursorPos(1,1)
	print ("Aby przerwac wcisnij Q")
	
	if v.roomType == "tunnel" then 
		tunnel()
		elseif v.roomType == "room" then room() 
		elseif v.roomType == "nofill" then nofill()
		elseif v.roomType == "wall" then wall()
		elseif v.roomType == "floor" then buildFloor()
		elseif v.roomType == "ceiling" then buildCeiling() 
		elseif v.roomType == "excavate" then excavate()
	end
	goToStart()
	dumpInv(true)
	sendAndPrint(endMsg)
end

function stop()
	while true do
		id, code = os.pullEvent("key")
		if code == 16 then
			return true
		end
	end
end

--=== Main executing part of the program ===--
if v.recId ~= nil then
	rednet.open("right")
end

parallel.waitForAny(stop, build)
fs.delete("rodbhPos.tmp")

end
